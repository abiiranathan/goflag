// genc is a code generator for the gflag package.
// It generates constructors for all the flag types.
// It is run as part of the go generate command.
// Usage: genc -c | -g <package> <output_file>
// Us -c to generate constructors and -g to generate getters.
package main

import (
	"fmt"
	"go/types"
	"os"
	"os/exec"
	"strings"

	"golang.org/x/tools/go/packages"
)

var typeMap = map[string]string{
	"flagString":       "string",
	"flagInt":          "int",
	"flagInt64":        "int64",
	"flagFloat32":      "float32",
	"flagFloat64":      "float64",
	"flagBool":         "bool",
	"flagRune":         "rune",
	"flagDuration":     "time.Duration",
	"flagStringSlice":  "[]string",
	"flagIntSlice":     "[]int",
	"flagTime":         "time.Time",
	"flagIP":           "net.IP",
	"flagMAC":          "net.HardwareAddr",
	"flagURL":          "*url.URL",
	"flagUUID":         "uuid.UUID",
	"flagHostPortPair": "string",
	"flagEmail":        "string",
	"flagFilePath":     "string",
	"flagDirPath":      "string",
}

var pkgImports = `
import (
	"time"
	"net"
	"net/url"
	"github.com/google/uuid"
)
`

func Constructor(name string, valueType string, flagType string) string {
	return fmt.Sprintf(`func %s(name, shortName string, value %s, usage string, required... bool) *gflag {
	flag := &gflag{
		name:      name,
		shortName: shortName,
		value:     value,
		flagType:  %s,
		usage:     usage,
	}
	if len(required) > 0 {
		flag.required = required[0]
	}
	return flag
}

`, name, valueType, flagType)
}

func Getter(name string, valueType string, flagType string) string {
	return fmt.Sprintf(`// Get the value of a flag as a %s. Panics if the flag is not found or the value is not a %s.
func (ctx *Context) Get%s(name string) %s {
	return ctx.Get(name).(%s)
}

func (cmd *subcommand) Get%s(name string) %s {
	return cmd.Get(name).(%s)
}

`,
		// Getter for context
		valueType, valueType, name, valueType, valueType,
		// getter for subcommand
		name, valueType, valueType)
}

func main() {
	if len(os.Args) != 4 {
		fmt.Println("Usage: genc -c | -g <package> <output_file>")
		os.Exit(1)
	}

	if os.Args[1] != "-c" && os.Args[1] != "-g" {
		fmt.Println("Usage: genc -c | -g <package> <output_file>")
		os.Exit(1)
	}

	cfg := &packages.Config{
		Mode:  packages.NeedName | packages.NeedTypes | packages.NeedTypesInfo | packages.NeedSyntax,
		Tests: false,
		BuildFlags: []string{
			"-tags=ignore_autogenerated",
		},
	}

	pkgs, err := packages.Load(cfg, os.Args[2])
	if err != nil {
		panic(err)
	}

	os.Remove(os.Args[3])
	f, err := os.OpenFile(os.Args[3], os.O_CREATE|os.O_WRONLY, 0644)
	if err != nil {
		panic(err)
	}
	defer f.Close()

	_, err = f.WriteString(fmt.Sprintf("// Code generated by genc. DO NOT EDIT.\n\npackage %s\n\n", pkgs[0].Name))
	if err != nil {
		panic(err)
	}

	_, err = f.WriteString(pkgImports)
	if err != nil {
		panic(err)
	}

	foundTypes := false
	// Iterate through packages and their types.
	for _, pkg := range pkgs {
		// Write the constructor to the output file.

		// Iterate through the package's scope to find the constants of type flagType.
		for _, name := range pkg.Types.Scope().Names() {
			obj := pkg.Types.Scope().Lookup(name)
			if obj == nil {
				continue
			}

			// Check if the constant is of type flagType.
			if c, ok := obj.(*types.Const); ok {
				if strings.HasSuffix(c.Type().String(), "flagType") {
					foundTypes = true
					constrName := strings.TrimPrefix(c.Name(), "flag")
					valueType := getValueType(c.Name())

					if os.Args[1] == "-c" {

						// Generate the constructor.
						text := Constructor(constrName, valueType, c.Name())
						_, err = f.WriteString(text)
						if err != nil {
							panic(err)
						}
					} else if os.Args[1] == "-g" {
						// Generate the getter.
						text := Getter(constrName, valueType, c.Name())
						fmt.Println(text)

						_, err = f.WriteString(text)
						if err != nil {
							panic(err)
						}
					}
				}

			}
		}
	}

	if !foundTypes {
		os.Remove(os.Args[3])
	}

	// format the output file.
	cmd := exec.Command("go", "fmt", os.Args[3])
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr
	err = cmd.Run()
	if err != nil {
		panic(err)
	}
}

func getValueType(flagType string) string {
	if value, ok := typeMap[flagType]; ok {
		return value
	}

	panic(fmt.Sprintf("unknown flag type %s\n", flagType))
}
