package goflag

import (
	"fmt"
	"io"
	"os"
	"path/filepath"
	"strings"
)

// GenBashCompletion generates a bash completion script and writes it to w.
// The completion script provides intelligent tab completion for commands, subcommands,
// and flags. Only long-form flags (--flag) are shown in completions to reduce clutter;
// short flags can still be used but won't appear in completion suggestions.
func (c *CLI) GenBashCompletion(w io.Writer) {
	binName := filepath.Base(os.Args[0])

	fmt.Fprintf(w, "#!/bin/bash\n")
	fmt.Fprintf(w, "# Bash completion for %s\n", binName)
	fmt.Fprintf(w, "# Generated by goflag\n\n")

	fmt.Fprintf(w, "_%s_completion() {\n", binName)
	fmt.Fprintf(w, "    local cur prev subcommands\n")
	fmt.Fprintf(w, "    cur=\"${COMP_WORDS[COMP_CWORD]}\"\n")
	fmt.Fprintf(w, "    prev=\"${COMP_WORDS[COMP_CWORD-1]}\"\n\n")

	// Collect global flags (long form only for cleaner completion)
	var globalFlags []string
	for _, f := range c.flags {
		globalFlags = append(globalFlags, "--"+f.name)
	}

	// Collect subcommand names
	var subCmdNames []string
	for _, cmd := range c.subcommands {
		subCmdNames = append(subCmdNames, cmd.name)
	}

	fmt.Fprintf(w, "    subcommands=\"%s\"\n", strings.Join(subCmdNames, " "))
	fmt.Fprintf(w, "    global_flags=\"%s\"\n\n", strings.Join(globalFlags, " "))

	// Handle flag arguments (Global) - include both long and short forms for matching
	fmt.Fprintf(w, "    # Handle flags that need arguments\n")
	fmt.Fprintf(w, "    case \"$prev\" in\n")
	for _, f := range c.flags {
		if f.flagType != FlagBool {
			flags := []string{"--" + f.name}
			if f.shortName != "" {
				flags = append(flags, "-"+f.shortName)
			}
			fmt.Fprintf(w, "        %s)\n", strings.Join(flags, "|"))
			// Suggest files or directories if the flag type matches
			switch f.flagType {
			case FlagDirPath:
				fmt.Fprintf(w, "            COMPREPLY=( $(compgen -d -- \"$cur\") )\n")
			case FlagFilePath:
				fmt.Fprintf(w, "            COMPREPLY=( $(compgen -f -- \"$cur\") )\n")
			}
			fmt.Fprintf(w, "            return 0\n")
			fmt.Fprintf(w, "            ;;\n")
		}
	}
	fmt.Fprintf(w, "    esac\n\n")

	// Check for subcommand context
	fmt.Fprintf(w, "    # Check for subcommand context\n")
	fmt.Fprintf(w, "    local cmd_context=\"\"\n")
	fmt.Fprintf(w, "    for word in \"${COMP_WORDS[@]}\"; do\n")
	fmt.Fprintf(w, "        for cmd in $subcommands; do\n")
	fmt.Fprintf(w, "            if [[ \"$word\" == \"$cmd\" ]]; then\n")
	fmt.Fprintf(w, "                cmd_context=\"$cmd\"\n")
	fmt.Fprintf(w, "                break\n")
	fmt.Fprintf(w, "            fi\n")
	fmt.Fprintf(w, "        done\n")
	fmt.Fprintf(w, "        if [[ -n \"$cmd_context\" ]]; then break; fi\n")
	fmt.Fprintf(w, "    done\n\n")

	// If no subcommand is active, suggest subcommands and global flags
	fmt.Fprintf(w, "    if [[ -z \"$cmd_context\" ]]; then\n")
	fmt.Fprintf(w, "        COMPREPLY=( $(compgen -W \"$subcommands $global_flags\" -- \"$cur\") )\n")
	fmt.Fprintf(w, "        return 0\n")
	fmt.Fprintf(w, "    fi\n\n")

	// Handle subcommand-specific completions
	fmt.Fprintf(w, "    case \"$cmd_context\" in\n")
	for _, cmd := range c.subcommands {
		fmt.Fprintf(w, "        %s)\n", cmd.name)

		// Handle subcommand flags that need arguments - include both long and short forms
		fmt.Fprintf(w, "            case \"$prev\" in\n")
		for _, f := range cmd.flags {
			if f.flagType != FlagBool {
				flags := []string{"--" + f.name}
				if f.shortName != "" {
					flags = append(flags, "-"+f.shortName)
				}
				fmt.Fprintf(w, "                %s)\n", strings.Join(flags, "|"))
				switch f.flagType {
				case FlagDirPath:
					fmt.Fprintf(w, "                    COMPREPLY=( $(compgen -d -- \"$cur\") )\n")
				case FlagFilePath:
					fmt.Fprintf(w, "                    COMPREPLY=( $(compgen -f -- \"$cur\") )\n")
				}
				fmt.Fprintf(w, "                    return 0\n")
				fmt.Fprintf(w, "                    ;;\n")
			}
		}
		fmt.Fprintf(w, "            esac\n\n")

		// Only show long-form flags in completions
		var subFlags []string
		for _, f := range cmd.flags {
			subFlags = append(subFlags, "--"+f.name)
		}

		fmt.Fprintf(w, "            local flags=\"%s\"\n", strings.Join(subFlags, " "))
		fmt.Fprintf(w, "            COMPREPLY=( $(compgen -W \"$flags\" -- \"$cur\") )\n")
		fmt.Fprintf(w, "            return 0\n")
		fmt.Fprintf(w, "            ;;\n")
	}

	fmt.Fprintf(w, "    esac\n\n")
	fmt.Fprintf(w, "    return 0\n")
	fmt.Fprintf(w, "}\n\n")
	fmt.Fprintf(w, "complete -F _%s_completion %s\n", binName, binName)
}

// GenZshCompletion generates a zsh completion script and writes it to w.
// The completion script provides intelligent tab completion for commands, subcommands,
// and flags. Only long-form flags (--flag) are shown in completions to reduce clutter;
// short flags can still be used but won't appear in completion suggestions.
//
// The completion will show both subcommands and global flags when pressing tab at the
// command prompt, making it easy to discover both options.
// GenZshCompletion generates a zsh completion script and writes it to w.
func (c *CLI) GenZshCompletion(w io.Writer) {
	binName := filepath.Base(os.Args[0])

	fmt.Fprintf(w, "#compdef %s\n", binName)
	fmt.Fprintf(w, "# Generated by goflag\n\n")

	fmt.Fprintf(w, "_%s() {\n", binName)
	fmt.Fprintf(w, "    local -a global_opts\n")
	fmt.Fprintf(w, "    local -a subcommands\n")
	fmt.Fprintf(w, "    local context state line\n")
	fmt.Fprintf(w, "    local ret=1\n\n")

	// Define Global Flags
	fmt.Fprintf(w, "    global_opts=(\n")
	for _, f := range c.flags {
		// Escape brackets in usage text as they are special in zsh _arguments
		desc := strings.ReplaceAll(f.usage, "]", "\\]")
		desc = strings.ReplaceAll(desc, "'", "'\\''")

		// Determine argument specification
		argSpec := ""
		switch f.flagType {
		case FlagBool:
			argSpec = ""
		case FlagDirPath:
			argSpec = ":dir:_files -/"
		case FlagFilePath:
			argSpec = ":file:_files"
		default:
			argSpec = ":value:"
		}

		// Display only long flags
		fmt.Fprintf(w, "        '--%s[%s]%s'\n", f.name, desc, argSpec)

	}
	fmt.Fprintf(w, "    )\n\n")

	// Define Subcommands
	if len(c.subcommands) > 0 {
		fmt.Fprintf(w, "    subcommands=(\n")
		for _, cmd := range c.subcommands {
			// Escape descriptions for Zsh string
			desc := strings.ReplaceAll(cmd.description, "'", "'\\''")
			// Zsh _arguments (( )) syntax expects 'name:description'
			fmt.Fprintf(w, "        '%s:%s'\n", cmd.name, desc)
		}
		fmt.Fprintf(w, "    )\n\n")
	}

	// Main _arguments call
	// We pass global_opts as normal arguments.
	// We pass subcommands specifically to the first positional argument.
	// Zsh automatically handles the "Flag OR Subcommand" logic here.
	fmt.Fprintf(w, "    _arguments -C \\\n")
	fmt.Fprintf(w, "        \"${global_opts[@]}\" \\\n")
	if len(c.subcommands) > 0 {
		// The (( )) syntax tells _arguments to use the subcommands array for completion items
		fmt.Fprintf(w, "        '1:command:((${subcommands}))' \\\n")
		fmt.Fprintf(w, "        '*::arg:->args' \\\n")
	}
	fmt.Fprintf(w, "        && ret=0\n\n")

	// State machine for subcommand-specific flags
	if len(c.subcommands) > 0 {
		fmt.Fprintf(w, "    case $state in\n")
		fmt.Fprintf(w, "        args)\n")
		fmt.Fprintf(w, "            case $line[1] in\n")

		for _, cmd := range c.subcommands {
			fmt.Fprintf(w, "                %s)\n", cmd.name)
			fmt.Fprintf(w, "                    _arguments -C \\\n")
			for _, f := range cmd.flags {
				desc := strings.ReplaceAll(f.usage, "]", "\\]")
				desc = strings.ReplaceAll(desc, "'", "'\\''")

				argSpec := ""
				switch f.flagType {
				case FlagBool:
					argSpec = ""
				case FlagDirPath:
					argSpec = ":dir:_files -/"
				case FlagFilePath:
					argSpec = ":file:_files"
				default:
					argSpec = ":value:"
				}

				// Show only long flags
				fmt.Fprintf(w, "                        '--%s[%s]%s' \\\n", f.name, desc, argSpec)

			}
			fmt.Fprintf(w, "                        && ret=0\n")
			fmt.Fprintf(w, "                    ;;\n")
		}

		fmt.Fprintf(w, "            esac\n")
		fmt.Fprintf(w, "            ;;\n")
		fmt.Fprintf(w, "    esac\n")
	}

	fmt.Fprintf(w, "    return ret\n")
	fmt.Fprintf(w, "}\n\n")
	fmt.Fprintf(w, "_%s \"$@\"\n", binName)
}

// InstallCompletion installs shell completion scripts for the CLI application.
// This function automatically detects the user's shell (bash or zsh) and installs
// the appropriate completion script to the user's home directory.
//
// For bash, the completion script is installed to ~/.bash_completion.d/<binName>
// and a source line is added to ~/.bashrc if not already present.
//
// For zsh, the completion script is installed to ~/.zsh/completion/_<binName>
// and the necessary fpath and compinit lines are added to ~/.zshrc if not already present.
//
// Parameters:
//   - shell: The shell to install completions for ("bash" or "zsh")
//
// Returns an error if installation fails.
//
// Example:
//
//	cli := goflag.NewCLI()
//	if err := cli.InstallCompletion("bash"); err != nil {
//	    fmt.Fprintf(os.Stderr, "Failed to install completion: %v\n", err)
//	}
func (c *CLI) InstallCompletion(shell string) error {
	binName := filepath.Base(os.Args[0])

	var generateFunc func(io.Writer)
	switch shell {
	case "bash":
		generateFunc = c.GenBashCompletion
	case "zsh":
		generateFunc = c.GenZshCompletion
	default:
		return fmt.Errorf("unsupported shell: %s (supported: bash, zsh)", shell)
	}

	return installCompletion(shell, binName, generateFunc)
}

// UninstallCompletion removes shell completion scripts for the CLI application.
// This function removes the completion script from the user's home directory and
// cleans up any references to it in shell configuration files.
//
// For bash, the completion script is removed from ~/.bash_completion.d/<binName>
// and the source line is removed from ~/.bashrc.
//
// For zsh, the completion script is removed from ~/.zsh/completion/_<binName>.
// Note that fpath and compinit lines remain in ~/.zshrc as they may be used by
// other completions.
//
// Parameters:
//   - shell: The shell to uninstall completions for ("bash" or "zsh")
//
// Returns an error if uninstallation fails.
//
// Example:
//
//	cli := goflag.NewCLI()
//	if err := cli.UninstallCompletion("bash"); err != nil {
//	    fmt.Fprintf(os.Stderr, "Failed to uninstall completion: %v\n", err)
//	}
func (c *CLI) UninstallCompletion(shell string) error {
	binName := filepath.Base(os.Args[0])
	return uninstallCompletion(shell, binName)
}

// installCompletion installs the completion script to the appropriate location
// installCompletion installs the completion script to the appropriate location
func installCompletion(shell, binName string, generateFunc func(io.Writer)) error {
	var installPath string
	var scriptContent strings.Builder

	generateFunc(&scriptContent)

	switch shell {
	case "bash":
		// Try user-specific location first
		homeDir, err := os.UserHomeDir()
		if err != nil {
			return fmt.Errorf("failed to get home directory: %w", err)
		}

		// Create bash completion directory
		completionDir := filepath.Join(homeDir, ".bash_completion.d")
		if err := os.MkdirAll(completionDir, 0755); err != nil {
			return fmt.Errorf("failed to create completion directory: %w", err)
		}

		installPath = filepath.Join(completionDir, binName)

		// Write the completion script
		if err := os.WriteFile(installPath, []byte(scriptContent.String()), 0644); err != nil {
			return fmt.Errorf("failed to write completion script: %w", err)
		}

		// Add source line to .bashrc if not already present
		bashrcPath := filepath.Join(homeDir, ".bashrc")
		sourceLine := fmt.Sprintf("source %s", installPath)

		// Check for the specific source line
		if err := addSourceLineIfMissing(bashrcPath, sourceLine, sourceLine); err != nil {
			fmt.Fprintf(os.Stderr, "Warning: Could not update .bashrc: %v\n", err)
			fmt.Fprintf(os.Stderr, "Add this line to your .bashrc manually:\n  %s\n", sourceLine)
		}

		fmt.Printf("Bash completion installed to: %s\n", installPath)
		fmt.Println("Run 'source ~/.bashrc' or restart your terminal to enable completions")

	case "zsh":
		homeDir, err := os.UserHomeDir()
		if err != nil {
			return fmt.Errorf("failed to get home directory: %w", err)
		}

		// Create zsh completion directory
		completionDir := filepath.Join(homeDir, ".zsh", "completion")
		if err := os.MkdirAll(completionDir, 0755); err != nil {
			return fmt.Errorf("failed to create completion directory: %w", err)
		}

		installPath = filepath.Join(completionDir, "_"+binName)

		// Write the completion script
		if err := os.WriteFile(installPath, []byte(scriptContent.String()), 0644); err != nil {
			return fmt.Errorf("failed to write completion script: %w", err)
		}

		// Add fpath and compinit to .zshrc if not already present
		zshrcPath := filepath.Join(homeDir, ".zshrc")

		// FIX: Use the literal string "~/.zsh/completion" for the check,
		// NOT the absolute path variable 'completionDir'
		fpathStr := "~/.zsh/completion"
		fpathLine := fmt.Sprintf("fpath=(%s $fpath)", fpathStr)
		compinitLine := "autoload -Uz compinit && compinit"

		if err := addSourceLineIfMissing(zshrcPath, fpathLine, fpathStr); err != nil {
			fmt.Fprintf(os.Stderr, "Warning: Could not update .zshrc: %v\n", err)
		}
		if err := addSourceLineIfMissing(zshrcPath, compinitLine, "compinit"); err != nil {
			fmt.Fprintf(os.Stderr, "Warning: Could not update .zshrc: %v\n", err)
		}

		fmt.Printf("Zsh completion installed to: %s\n", installPath)
		fmt.Println("Run 'source ~/.zshrc' or restart your terminal to enable completions")

	default:
		return fmt.Errorf("unsupported shell: %s", shell)
	}

	return nil
}

// addSourceLineIfMissing adds a line to the beginning of a shell rc file if it's not already present
func addSourceLineIfMissing(rcPath, line, checkStr string) error {
	// Read existing content
	content, err := os.ReadFile(rcPath)
	if err != nil {
		if os.IsNotExist(err) {
			// File doesn't exist, create it
			return os.WriteFile(rcPath, []byte(line+"\n"), 0644)
		}
		return err
	}

	// Check if the line or similar already exists
	if strings.Contains(string(content), checkStr) {
		return nil // Already present
	}

	// Prepend the line (add to beginning)
	newContent := line + "\n" + string(content)
	return os.WriteFile(rcPath, []byte(newContent), 0644)
}

// uninstallCompletion removes the completion script and cleans up rc files
func uninstallCompletion(shell, binName string) error {
	homeDir, err := os.UserHomeDir()
	if err != nil {
		return fmt.Errorf("failed to get home directory: %w", err)
	}

	switch shell {
	case "bash":
		// Remove completion script
		completionPath := filepath.Join(homeDir, ".bash_completion.d", binName)
		if err := os.Remove(completionPath); err != nil && !os.IsNotExist(err) {
			return fmt.Errorf("failed to remove completion script: %w", err)
		}

		// Remove source line from .bashrc
		bashrcPath := filepath.Join(homeDir, ".bashrc")
		if err := removeSourceLine(bashrcPath, completionPath); err != nil {
			fmt.Fprintf(os.Stderr, "Warning: Could not update .bashrc: %v\n", err)
			fmt.Fprintf(os.Stderr, "You may need to manually remove the source line for: %s\n", completionPath)
		}

		fmt.Printf("Bash completion uninstalled from: %s\n", completionPath)
		fmt.Println("Run 'source ~/.bashrc' or restart your terminal to complete removal")

	case "zsh":
		// Remove completion script
		completionPath := filepath.Join(homeDir, ".zsh", "completion", "_"+binName)
		if err := os.Remove(completionPath); err != nil && !os.IsNotExist(err) {
			return fmt.Errorf("failed to remove completion script: %w", err)
		}

		fmt.Printf("Zsh completion uninstalled from: %s\n", completionPath)
		fmt.Println("Note: fpath and compinit lines remain in .zshrc for other completions")
		fmt.Println("Run 'source ~/.zshrc' or restart your terminal to complete removal")

	default:
		return fmt.Errorf("unsupported shell: %s", shell)
	}

	return nil
}

// removeSourceLine removes a line containing the checkStr from the rc file
func removeSourceLine(rcPath, checkStr string) error {
	content, err := os.ReadFile(rcPath)
	if err != nil {
		if os.IsNotExist(err) {
			return nil // File doesn't exist, nothing to remove
		}
		return err
	}

	lines := strings.Split(string(content), "\n")
	var newLines []string

	for _, line := range lines {
		// Skip lines that contain the completion path
		if !strings.Contains(line, checkStr) {
			newLines = append(newLines, line)
		}
	}

	// Only write if we actually removed something
	if len(newLines) != len(lines) {
		return os.WriteFile(rcPath, []byte(strings.Join(newLines, "\n")), 0644)
	}

	return nil
}
