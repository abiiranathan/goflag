package goflag

import (
	"fmt"
	"io"
	"os"
	"path/filepath"
	"strings"
)

// GenBashCompletion generates a bash completion script and writes it to w.
func (c *CLI) GenBashCompletion(w io.Writer) {
	binName := filepath.Base(os.Args[0])

	fmt.Fprintf(w, "#!/bin/bash\n")
	fmt.Fprintf(w, "# Bash completion for %s\n", binName)
	fmt.Fprintf(w, "# Generated by goflag\n\n")

	fmt.Fprintf(w, "_%s_completion() {\n", binName)
	fmt.Fprintf(w, "    local cur prev subcommands\n")
	fmt.Fprintf(w, "    cur=\"${COMP_WORDS[COMP_CWORD]}\"\n")
	fmt.Fprintf(w, "    prev=\"${COMP_WORDS[COMP_CWORD-1]}\"\n\n")

	// Collect global flags
	var globalFlags []string
	for _, f := range c.flags {
		globalFlags = append(globalFlags, "--"+f.name)
		if f.shortName != "" {
			globalFlags = append(globalFlags, "-"+f.shortName)
		}
	}

	// Collect subcommand names
	var subCmdNames []string
	for _, cmd := range c.subcommands {
		subCmdNames = append(subCmdNames, cmd.name)
	}

	fmt.Fprintf(w, "    subcommands=\"%s\"\n", strings.Join(subCmdNames, " "))
	fmt.Fprintf(w, "    global_flags=\"%s\"\n\n", strings.Join(globalFlags, " "))

	// Handle flag arguments (Global)
	fmt.Fprintf(w, "    # Handle flags that need arguments\n")
	fmt.Fprintf(w, "    case \"$prev\" in\n")
	for _, f := range c.flags {
		if f.flagType != FlagBool {
			flags := []string{"--" + f.name}
			if f.shortName != "" {
				flags = append(flags, "-"+f.shortName)
			}
			fmt.Fprintf(w, "        %s)\n", strings.Join(flags, "|"))
			// Suggest files or directories if the flag type matches
			switch f.flagType {
			case FlagDirPath:
				fmt.Fprintf(w, "            COMPREPLY=( $(compgen -d -- \"$cur\") )\n")
			case FlagFilePath:
				fmt.Fprintf(w, "            COMPREPLY=( $(compgen -f -- \"$cur\") )\n")
			}
			fmt.Fprintf(w, "            return 0\n")
			fmt.Fprintf(w, "            ;;\n")
		}
	}
	fmt.Fprintf(w, "    esac\n\n")

	// Check for subcommand context
	fmt.Fprintf(w, "    # Check for subcommand context\n")
	fmt.Fprintf(w, "    local cmd_context=\"\"\n")
	fmt.Fprintf(w, "    for word in \"${COMP_WORDS[@]}\"; do\n")
	fmt.Fprintf(w, "        for cmd in $subcommands; do\n")
	fmt.Fprintf(w, "            if [[ \"$word\" == \"$cmd\" ]]; then\n")
	fmt.Fprintf(w, "                cmd_context=\"$cmd\"\n")
	fmt.Fprintf(w, "                break\n")
	fmt.Fprintf(w, "            fi\n")
	fmt.Fprintf(w, "        done\n")
	fmt.Fprintf(w, "        if [[ -n \"$cmd_context\" ]]; then break; fi\n")
	fmt.Fprintf(w, "    done\n\n")

	// If no subcommand is active, suggest subcommands and global flags
	fmt.Fprintf(w, "    if [[ -z \"$cmd_context\" ]]; then\n")
	fmt.Fprintf(w, "        COMPREPLY=( $(compgen -W \"$subcommands $global_flags\" -- \"$cur\") )\n")
	fmt.Fprintf(w, "        return 0\n")
	fmt.Fprintf(w, "    fi\n\n")

	// Handle subcommand-specific completions
	fmt.Fprintf(w, "    case \"$cmd_context\" in\n")
	for _, cmd := range c.subcommands {
		fmt.Fprintf(w, "        %s)\n", cmd.name)

		// Handle subcommand flags that need arguments
		fmt.Fprintf(w, "            case \"$prev\" in\n")
		for _, f := range cmd.flags {
			if f.flagType != FlagBool {
				flags := []string{"--" + f.name}
				if f.shortName != "" {
					flags = append(flags, "-"+f.shortName)
				}
				fmt.Fprintf(w, "                %s)\n", strings.Join(flags, "|"))
				switch f.flagType {
				case FlagDirPath:
					fmt.Fprintf(w, "                    COMPREPLY=( $(compgen -d -- \"$cur\") )\n")
				case FlagFilePath:
					fmt.Fprintf(w, "                    COMPREPLY=( $(compgen -f -- \"$cur\") )\n")
				}
				fmt.Fprintf(w, "                    return 0\n")
				fmt.Fprintf(w, "                    ;;\n")
			}
		}
		fmt.Fprintf(w, "            esac\n\n")

		var subFlags []string
		for _, f := range cmd.flags {
			subFlags = append(subFlags, "--"+f.name)
			if f.shortName != "" {
				subFlags = append(subFlags, "-"+f.shortName)
			}
		}

		fmt.Fprintf(w, "            local flags=\"%s\"\n", strings.Join(subFlags, " "))
		fmt.Fprintf(w, "            COMPREPLY=( $(compgen -W \"$flags\" -- \"$cur\") )\n")
		fmt.Fprintf(w, "            return 0\n")
		fmt.Fprintf(w, "            ;;\n")
	}

	fmt.Fprintf(w, "    esac\n\n")
	fmt.Fprintf(w, "    return 0\n")
	fmt.Fprintf(w, "}\n\n")
	fmt.Fprintf(w, "complete -F _%s_completion %s\n", binName, binName)
}

// GenZshCompletion generates a zsh completion script and writes it to w.
// GenZshCompletion generates a zsh completion script and writes it to w.
func (c *CLI) GenZshCompletion(w io.Writer) {
	binName := filepath.Base(os.Args[0])

	fmt.Fprintf(w, "#compdef %s\n", binName)
	fmt.Fprintf(w, "# Generated by goflag\n\n")

	fmt.Fprintf(w, "_%s() {\n", binName)
	fmt.Fprintf(w, "    local -a global_opts\n")
	fmt.Fprintf(w, "    local context state line\n")
	fmt.Fprintf(w, "    local ret=1\n\n")

	// Define Global Flags
	fmt.Fprintf(w, "    global_opts=(\n")
	for _, f := range c.flags {
		// Escape brackets in usage text as they are special in zsh _arguments
		desc := strings.ReplaceAll(f.usage, "]", "\\]")
		desc = strings.ReplaceAll(desc, "'", "'\\''")

		// Determine argument specification
		argSpec := ""
		switch f.flagType {
		case FlagBool:
			argSpec = ""
		case FlagDirPath:
			argSpec = ":dir:_files -/"
		case FlagFilePath:
			argSpec = ":file:_files"
		default:
			argSpec = ":value:"
		}

		if f.shortName != "" {
			fmt.Fprintf(w, "        '(-%s --%s)'{-%s,--%s}'[%s]%s'\n",
				f.shortName, f.name, f.shortName, f.name, desc, argSpec)
		} else {
			fmt.Fprintf(w, "        '--%s[%s]%s'\n", f.name, desc, argSpec)
		}
	}
	fmt.Fprintf(w, "    )\n\n")

	// Build subcommands array - properly escape for zsh
	if len(c.subcommands) > 0 {
		fmt.Fprintf(w, "    local -a subcommands\n")
		fmt.Fprintf(w, "    subcommands=(\n")
		for _, cmd := range c.subcommands {
			// Properly escape the description for zsh
			// Single quotes in zsh arrays need special handling
			desc := strings.ReplaceAll(cmd.description, "'", "'\"'\"'")
			fmt.Fprintf(w, "        '%s:%s'\n", cmd.name, desc)
		}
		fmt.Fprintf(w, "    )\n\n")
	}

	// Main _arguments call
	fmt.Fprintf(w, "    _arguments -C \\\n")
	fmt.Fprintf(w, "        \"${global_opts[@]}\" \\\n")
	if len(c.subcommands) > 0 {
		fmt.Fprintf(w, "        '1:command:->command' \\\n")
		fmt.Fprintf(w, "        '*::arg:->args' \\\n")
	}
	fmt.Fprintf(w, "        && ret=0\n\n")

	// State machine for subcommands
	if len(c.subcommands) > 0 {
		fmt.Fprintf(w, "    case $state in\n")
		fmt.Fprintf(w, "        command)\n")
		fmt.Fprintf(w, "            _describe 'command' subcommands && ret=0\n")
		fmt.Fprintf(w, "            ;;\n")
		fmt.Fprintf(w, "        args)\n")
		fmt.Fprintf(w, "            case $line[1] in\n")

		for _, cmd := range c.subcommands {
			fmt.Fprintf(w, "                %s)\n", cmd.name)
			fmt.Fprintf(w, "                    _arguments -C \\\n")
			for _, f := range cmd.flags {
				desc := strings.ReplaceAll(f.usage, "]", "\\]")
				desc = strings.ReplaceAll(desc, "'", "'\\''")

				argSpec := ""
				switch f.flagType {
				case FlagBool:
					argSpec = ""
				case FlagDirPath:
					argSpec = ":dir:_files -/"
				case FlagFilePath:
					argSpec = ":file:_files"
				default:
					argSpec = ":value:"
				}

				if f.shortName != "" {
					fmt.Fprintf(w, "                        '(-%s --%s)'{-%s,--%s}'[%s]%s' \\\n",
						f.shortName, f.name, f.shortName, f.name, desc, argSpec)
				} else {
					fmt.Fprintf(w, "                        '--%s[%s]%s' \\\n", f.name, desc, argSpec)
				}
			}
			fmt.Fprintf(w, "                        && ret=0\n")
			fmt.Fprintf(w, "                    ;;\n")
		}

		fmt.Fprintf(w, "            esac\n")
		fmt.Fprintf(w, "            ;;\n")
		fmt.Fprintf(w, "    esac\n")
	}

	fmt.Fprintf(w, "    return ret\n")
	fmt.Fprintf(w, "}\n\n")
	fmt.Fprintf(w, "_%s \"$@\"\n", binName)
}

// installCompletion installs the completion script to the appropriate location
func installCompletion(shell, binName string, generateFunc func(io.Writer)) error {
	var installPath string
	var scriptContent strings.Builder

	generateFunc(&scriptContent)

	switch shell {
	case "bash":
		// Try user-specific location first
		homeDir, err := os.UserHomeDir()
		if err != nil {
			return fmt.Errorf("failed to get home directory: %w", err)
		}

		// Create bash completion directory
		completionDir := filepath.Join(homeDir, ".bash_completion.d")
		if err := os.MkdirAll(completionDir, 0755); err != nil {
			return fmt.Errorf("failed to create completion directory: %w", err)
		}

		installPath = filepath.Join(completionDir, binName)

		// Write the completion script
		if err := os.WriteFile(installPath, []byte(scriptContent.String()), 0644); err != nil {
			return fmt.Errorf("failed to write completion script: %w", err)
		}

		// Add source line to .bashrc if not already present
		bashrcPath := filepath.Join(homeDir, ".bashrc")
		sourceLine := fmt.Sprintf("source %s", installPath)

		if err := addSourceLineIfMissing(bashrcPath, sourceLine, installPath); err != nil {
			fmt.Fprintf(os.Stderr, "Warning: Could not update .bashrc: %v\n", err)
			fmt.Fprintf(os.Stderr, "Add this line to your .bashrc manually:\n  %s\n", sourceLine)
		}

		fmt.Printf("Bash completion installed to: %s\n", installPath)
		fmt.Println("Run 'source ~/.bashrc' or restart your terminal to enable completions")

	case "zsh":
		homeDir, err := os.UserHomeDir()
		if err != nil {
			return fmt.Errorf("failed to get home directory: %w", err)
		}

		// Create zsh completion directory
		completionDir := filepath.Join(homeDir, ".zsh", "completion")
		if err := os.MkdirAll(completionDir, 0755); err != nil {
			return fmt.Errorf("failed to create completion directory: %w", err)
		}

		installPath = filepath.Join(completionDir, "_"+binName)

		// Write the completion script
		if err := os.WriteFile(installPath, []byte(scriptContent.String()), 0644); err != nil {
			return fmt.Errorf("failed to write completion script: %w", err)
		}

		// Add fpath and compinit to .zshrc if not already present
		zshrcPath := filepath.Join(homeDir, ".zshrc")
		fpathLine := "fpath=(~/.zsh/completion $fpath)"
		compinitLine := "autoload -Uz compinit && compinit"

		if err := addSourceLineIfMissing(zshrcPath, fpathLine, completionDir); err != nil {
			fmt.Fprintf(os.Stderr, "Warning: Could not update .zshrc: %v\n", err)
		}
		if err := addSourceLineIfMissing(zshrcPath, compinitLine, "compinit"); err != nil {
			fmt.Fprintf(os.Stderr, "Warning: Could not update .zshrc: %v\n", err)
		}

		fmt.Printf("Zsh completion installed to: %s\n", installPath)
		fmt.Println("Run 'source ~/.zshrc' or restart your terminal to enable completions")

	default:
		return fmt.Errorf("unsupported shell: %s", shell)
	}

	return nil
}

// addSourceLineIfMissing adds a line to a shell rc file if it's not already present
func addSourceLineIfMissing(rcPath, line, checkStr string) error {
	// Read existing content
	content, err := os.ReadFile(rcPath)
	if err != nil {
		if os.IsNotExist(err) {
			// File doesn't exist, create it
			return os.WriteFile(rcPath, []byte(line+"\n"), 0644)
		}
		return err
	}

	// Check if the line or similar already exists
	if strings.Contains(string(content), checkStr) {
		return nil // Already present
	}

	// Append the line
	f, err := os.OpenFile(rcPath, os.O_APPEND|os.O_WRONLY, 0644)
	if err != nil {
		return err
	}
	defer f.Close()

	_, err = f.WriteString("\n" + line + "\n")
	return err
}

// uninstallCompletion removes the completion script and cleans up rc files
func uninstallCompletion(shell, binName string) error {
	homeDir, err := os.UserHomeDir()
	if err != nil {
		return fmt.Errorf("failed to get home directory: %w", err)
	}

	switch shell {
	case "bash":
		// Remove completion script
		completionPath := filepath.Join(homeDir, ".bash_completion.d", binName)
		if err := os.Remove(completionPath); err != nil && !os.IsNotExist(err) {
			return fmt.Errorf("failed to remove completion script: %w", err)
		}

		// Remove source line from .bashrc
		bashrcPath := filepath.Join(homeDir, ".bashrc")
		if err := removeSourceLine(bashrcPath, completionPath); err != nil {
			fmt.Fprintf(os.Stderr, "Warning: Could not update .bashrc: %v\n", err)
			fmt.Fprintf(os.Stderr, "You may need to manually remove the source line for: %s\n", completionPath)
		}

		fmt.Printf("Bash completion uninstalled from: %s\n", completionPath)
		fmt.Println("Run 'source ~/.bashrc' or restart your terminal to complete removal")

	case "zsh":
		// Remove completion script
		completionPath := filepath.Join(homeDir, ".zsh", "completion", "_"+binName)
		if err := os.Remove(completionPath); err != nil && !os.IsNotExist(err) {
			return fmt.Errorf("failed to remove completion script: %w", err)
		}

		fmt.Printf("Zsh completion uninstalled from: %s\n", completionPath)
		fmt.Println("Note: fpath and compinit lines remain in .zshrc for other completions")
		fmt.Println("Run 'source ~/.zshrc' or restart your terminal to complete removal")

	default:
		return fmt.Errorf("unsupported shell: %s", shell)
	}

	return nil
}

// removeSourceLine removes a line containing the checkStr from the rc file
func removeSourceLine(rcPath, checkStr string) error {
	content, err := os.ReadFile(rcPath)
	if err != nil {
		if os.IsNotExist(err) {
			return nil // File doesn't exist, nothing to remove
		}
		return err
	}

	lines := strings.Split(string(content), "\n")
	var newLines []string

	for _, line := range lines {
		// Skip lines that contain the completion path
		if !strings.Contains(line, checkStr) {
			newLines = append(newLines, line)
		}
	}

	// Only write if we actually removed something
	if len(newLines) != len(lines) {
		return os.WriteFile(rcPath, []byte(strings.Join(newLines, "\n")), 0644)
	}

	return nil
}
